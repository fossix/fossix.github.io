<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>process on Fossix</title><link>https://fossix.org/tags/process/</link><description>Recent content in process on Fossix</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 26 Mar 2017 14:11:53 +0530</lastBuildDate><atom:link href="https://fossix.org/tags/process/index.xml" rel="self" type="application/rss+xml"/><item><title>Program Sections</title><link>https://fossix.org/posts/2013-07-26-program-sections/</link><pubDate>Sun, 26 Mar 2017 14:11:53 +0530</pubDate><guid>https://fossix.org/posts/2013-07-26-program-sections/</guid><description>Every program is split into multiple sections. In general, these are:
The code segment containing executable code The stack segment Data segment, which constitute the following: BSS Uninitialized data Heap Memory allocated during run time Data Initialized data They are just the defaults, there can be many more sections in a binary. For example our sample code contains the following different sections.
$ objdump -h a.out Most of the section compiled into the binary is either empty or just debugging information.</description></item><item><title>The exec() system call</title><link>https://fossix.org/posts/2013-07-25-the-exec-system-call/</link><pubDate>Sat, 25 Mar 2017 14:11:53 +0530</pubDate><guid>https://fossix.org/posts/2013-07-25-the-exec-system-call/</guid><description>After a successful fork() the child process will start to execute the command typed by the user, in our case the a.out file. This execution is started by the exec system call. The job of the system call is to overlay the calling process’ address space with the executable image and give control to it. The exec() syscall does the following functions:
The files shared by the parent and child processes are unshared, a new unknown executable shouldn’t be sharing files with the shell The executable file is opened and checked for permissions whether the new file has executable and open permission for the current user.</description></item><item><title>The fork() system call</title><link>https://fossix.org/posts/2013-07-24-the-fork-system-call/</link><pubDate>Fri, 24 Mar 2017 14:11:53 +0530</pubDate><guid>https://fossix.org/posts/2013-07-24-the-fork-system-call/</guid><description>As we know system calls take us from the user-land to the kernel-land. As mentioned earlier this article will describe even the very obvious details, so pardon the gory details. The different things that happen in the kernel during the start up of a process is what we will discuss in this section.
As seen in the last code listing, the shell does a fork() and calls exec family of system calls to overlay the command image onto the newly created child process’ address space.</description></item><item><title>Call Stack for Beginners - Part 1</title><link>https://fossix.org/posts/2014-07-19-call-stack-basics/</link><pubDate>Sat, 19 Jul 2014 15:12:53 +0530</pubDate><guid>https://fossix.org/posts/2014-07-19-call-stack-basics/</guid><description>Every process, no matter how it came into being, has at least one stack for the purpose of running itself. The programming language can be anything but it needs a stack to run. As usual is the custom we will write a c program to explain the concepts in a more detail. Before that we will have a basic understanding of why a stack is used and what’s its purpose (If you are really new to this world, then you should see what is stack first).</description></item><item><title>Dynamic linker and loader</title><link>https://fossix.org/posts/2013-07-27-dynamic-linker-and-loader/</link><pubDate>Sat, 27 Jul 2013 15:12:53 +0530</pubDate><guid>https://fossix.org/posts/2013-07-27-dynamic-linker-and-loader/</guid><description>As you would have noticed the beginning of the document, it was told the explanation will be based on the program we had written earlier in this series. The program was compiled using the command
$ cc sample-source.c -lm As you have probably noticed, we are linking the program with the math library. This was done intentionally to explain the dynamic loader. Any file can be identified using the file command.</description></item><item><title>The Birth of a Process</title><link>https://fossix.org/posts/2013-07-23-the-birth-of-a-process/</link><pubDate>Tue, 23 Jul 2013 14:11:53 +0530</pubDate><guid>https://fossix.org/posts/2013-07-23-the-birth-of-a-process/</guid><description>A process is born when a program is executed. So let us back-track a little more and start from the program birth. The program is born when there is a need for the programmer. So now I have a need to write a program so that I could create a process out of it and start explaining what happens along the way. The following is the sample code used for explaining various concepts in the rest of the article.</description></item><item><title>The life of a Process</title><link>https://fossix.org/posts/2013-07-20-the-life-of-a-process/</link><pubDate>Sat, 20 Jul 2013 14:10:52 +0530</pubDate><guid>https://fossix.org/posts/2013-07-20-the-life-of-a-process/</guid><description>The computer system is becoming a complex beast which cannot be tamed easily. In the new world the operating systems have become too big and complex for one to learn everything in depth. Most new aspiring system programmers do not have a picture of what is happening in a system when you type ./a.out. This article is an attempt to provide the picture and also the necessary details for a Linux newcomer to grasp so that he/she can refer to more detailed books for further learning.</description></item></channel></rss>