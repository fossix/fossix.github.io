<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on Fossix</title><link>https://fossix.org/tags/golang/</link><description>Recent content in golang on Fossix</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 14 Nov 2018 11:29:17 +0530</lastBuildDate><atom:link href="https://fossix.org/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Concurrency notes</title><link>https://fossix.org/posts/2018-11-14-golang-concurrency/</link><pubDate>Wed, 14 Nov 2018 11:29:17 +0530</pubDate><guid>https://fossix.org/posts/2018-11-14-golang-concurrency/</guid><description>Deadlock package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;time&amp;quot; ) type value struct { mu sync.Mutex v int } var wg sync.WaitGroup func print(i, j *value) { defer wg.Done() i.mu.Lock() defer i.mu.Unlock() time.Sleep(2 * time.Second) j.mu.Lock() defer j.mu.Unlock() fmt.Print(i.v + j.v) } func main() { a := &amp;amp;value{v: 1} b := &amp;amp;value{v: 2} var wg sync.WaitGroup wg.Add(2) go print(a, b) go print(b, a) wg.Wait() fmt.Println(&amp;quot;reached here?&amp;quot;) } Are they meeting coffman conditions:</description></item><item><title>Go's json marshal</title><link>https://fossix.org/posts/2018-09-11-go-json-marhsal-empty-slice/</link><pubDate>Tue, 11 Sep 2018 11:16:17 +0700</pubDate><guid>https://fossix.org/posts/2018-09-11-go-json-marhsal-empty-slice/</guid><description>When marshalling, if the variable reference is nil then json lib encodes it as nil. But for an empty slice the preferrence is to have [].</description></item><item><title>Dockerize go programs</title><link>https://fossix.org/posts/2018-08-14-golang-docker/</link><pubDate>Tue, 14 Aug 2018 11:29:17 +0530</pubDate><guid>https://fossix.org/posts/2018-08-14-golang-docker/</guid><description>Assume this is the production grade program we need to dockerize and run.
package main import &amp;quot;fmt&amp;quot; func main() { fmt.Println(&amp;quot;saying hello to the world&amp;quot;) } FROM golang:1.10-alpine as builder WORKDIR /go/src/github.com/shabinesh/prog COPY main.go . COPY vendor ./vendor RUN CGO_ENABLED=0 go build -o main . FROM alpine:latest RUN apk --no-cache add ca-certificates WORKDIR / COPY --from=0 /go/src/github.com/shabinesh/prog/main . CMD [&amp;quot;./main&amp;quot;]</description></item><item><title>Elegant Time</title><link>https://fossix.org/posts/2018-02-15-elegant-time-pref-in-go/</link><pubDate>Mon, 25 Dec 2017 11:29:17 +0530</pubDate><guid>https://fossix.org/posts/2018-02-15-elegant-time-pref-in-go/</guid><description>I often write debug logs with this below piece of code to print how much time a function took
func upload() { start := time.Now() // processing fmt.Println(&amp;quot;uploaded in %s secs&amp;quot;, time.Now().Sub(start)) } thats two lines, plus I should always remember to write that last line of code, With Golang&amp;rsquo;s deferred function it just one line
func totalTime(t time.Time) { fmt.Print(time.Now().Sub(t)) } func main() { defer totalTime(time.Now()) time.Sleep(1*time.Second) fmt.Println(&amp;quot;Hello, playground&amp;quot;) } Here we use the fact of deferred function that arguments are evaluated first and the function is called after return of callee.</description></item><item><title>SOLID principles in Golang</title><link>https://fossix.org/posts/2017-03-23-solid-principals/</link><pubDate>Thu, 23 Mar 2017 11:39:17 +0530</pubDate><guid>https://fossix.org/posts/2017-03-23-solid-principals/</guid><description>As a precursor to the common design pattern in game dev which is possibly a follow up post. The credits for any information put up here goes to Dave Cheney from where I have derived this material.
What is SOLID? The SOLID principles are the top five, rather important patterns usually found the Object oriented programming languages. Ref: Wikipedia
However the post is not intended to learn these principles, there are much better resources elsewhere for that.</description></item><item><title>Go's Reflection</title><link>https://fossix.org/posts/2017-03-08-go-reflection/</link><pubDate>Wed, 08 Mar 2017 11:39:17 +0530</pubDate><guid>https://fossix.org/posts/2017-03-08-go-reflection/</guid><description>Go&amp;rsquo;s reflection Reflection is used by the Go program to inspect types at runtime. Some understanding of Go&amp;rsquo;s interface{} is required before proceeding.
Consider a hypothetical requirement to build a validation for structures. In usual case I would prefer a if-else statement.
type Employee struct { Name string `json:&amp;quot;name&amp;quot;` Address string `json:&amp;quot;address&amp;quot;` Age int `json:&amp;quot;age&amp;quot;` } var e Employee err := json.Unmarshal(data, &amp;amp;e) // validate each field if e.Name == &amp;quot;&amp;quot; { log.</description></item></channel></rss>