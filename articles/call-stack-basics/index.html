<!doctype html><html><head>
<link rel=stylesheet href=/syntax.css>
<link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous>
<link href=/fossix.css rel=stylesheet media=screen>
<title>
Fossix - Call Stack for Beginners - Part 1
</title>
<script data-ad-client=ca-pub-0086577717613608 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta charset=utf-8>
</head>
<body><nav class="navbar navbar-expand-md navbar-dark bg-dark">
<a class=navbar-brand href=/>
<img src=/site-logo.png width=40 height=45 class="d-inline-block align-top" alt>
<span class=front-site-title>Fossix</span>
</a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span>
</button>
<div class="collapse navbar-collapse" id=navbarSupportedContent>
<ul class="navbar-nav mr-auto">
<li class=nav-item>
<a href=/categories/snippets class=nav-link>
Snippets
</a>
</li>
<li class=nav-item>
<a href=/categories/blogs class=nav-link>
Blogs
</a>
</li>
<li class=nav-item>
<a href=/categories/articles class=nav-link>
Articles
</a>
</li>
<li class=nav-item>
<a class=nav-link href=/archive/>
Archive
</a>
</li>
</ul>
</div>
</nav>
<div class=container-fluid style=margin-top:25px>
<div class=row>
<div class=col-lg-3>
</div>
<div class="col-lg-6 content">
<h1>Call Stack for Beginners - Part 1</h1>
<div class=alert-light>
<div class=float-left>
<span class=badge>
19 July, 2014 | santosh
</span>
</div>
<div class=float-right>
<a href=https://fossix.org/tagsprocess class="badge badge-light">#process</a>
<a href=https://fossix.org/tagslinux class="badge badge-light">#linux</a>
<a href=https://fossix.org/tagsstack class="badge badge-light">#stack</a>
</div>
<span class=badge> </span>
</div>
<hr>
<p>Every process, no matter how it came into being, has at least one stack for the
purpose of running itself. The programming language can be anything but it needs
a stack to run. As usual is the custom we will write a c program to explain the
concepts in a more detail. Before that we will have a basic understanding of why
a stack is used and what’s its purpose (If you are really new to this world,
then you should
see <a href=http://en.wikipedia.org/wiki/Stack_%28abstract_data_type%29>what is stack</a>
first). Why stack?</p>
<p>Accomplishing a task with a computer program involves many steps, some steps can
be repeatitive. This is the basis of the evolution of programming languages,
functions. Functions can eliminate the repeatitive steps in your
program. Assuming we never invented or know how to use stacks in computers, lets
think about the program execution. The below will be missed out if we don’t have
a stack.</p>
<ul>
<li>Lack of local variables, global variables are only available which then will make program more error prone.</li>
<li>Real functions can’t exist, since a function has to return to its caller by storing return address.</li>
<li>Threads can’t exist.</li>
<li>Code size will increase, since functions will be just like macros (All functions have to be in-lined)</li>
</ul>
<p>With such great advantages of a stack, all computers (microprocessors,
microcontollers etc) have built-in support for stack.</p>
<h1 id=the-working-of-a-stack>The working of a stack</h1>
<p>A stack is created when a process starts to run. The stack placement is based on
the operating system and architecture of the microprocessor. On a x86 machine,
the stack will be placed at the top of the address space of the process, and
then it grows down. The Linux kernel makes an anonymous mapping of a memory area
for the stack and sets VM flags with <code>VM_GROWSDOWN</code>. So on a page fault the
kernel maps more memory for the stack, which equals a <code>PAGE_SIZE</code>, starting from
the end of the stack (stack top). Theoretically stack can grow until there is no
more room in the memory. But usually the stack size is limited by the system
configuration.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-console data-lang=console><span class=gp>$ </span><span class=nb>ulimit</span> -s <span class=c1># Maximum stack size of a program  (soft limit)</span>
<span class=go>8192
</span><span class=go></span><span class=gp>$ </span><span class=nb>ulimit</span> -Hs <span class=c1># hard limit</span>
<span class=go>unlimited
</span></code></pre></div><p>When there is no limit we should ideally expect the program to be killed only
when we run out of memory (OOM), but we have something called stack overflow
too, which can occur even when enough physical memory is available. Stack
overflow occurs when stack grows down and reaches the region where the next
segment is present, which is the memory mapped area. So there is a hidden
limit. To clarify lets see a rough layout of a process in memory. The next
segment, which contains the memory maps for shared library etc. is placed after
rlimit size with some offset. The following diagram can explain better.</p>
<p><img src=/images/call-stack-basic.png alt="Call Stack"></p>
<p>Does stack always grow downwards? Not for all architectures. At least in IA64
the stack grows up, so kind of the above diagram inverted.</p>
<p>Above the stack is the kernel space, and below the heap are the other sections
of the program, like the <code>BSS</code>, <code>Data</code>, <code>Text</code> (Code) etc. etc., which we will
take up in a later article.</p>
<h1 id=contents-of-a-stack>Contents of a stack</h1>
<p>Before getting into the details of what constitutes the stack, we will touch
upon the hardware support for stack. Most hardware have good support to make
stack usage very efficient. Usually a dedicated register is used to save the
address of the top of stack, called the stack pointer. Also instructions are
provided for pushing and popping elements in and out the stack. In x86 the stack
pointer register is called <code>ESP</code><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p>
<p>In C when each function is called a dedicated space for the function is created
in the stack, that’s called a stack frame. Those are like scratch-pads for the
functions, and this frame will be destroyed when the function returns. The frame
is also very important and very much used, which warrants for a dedicated
register. This is typically called the frame pointer <code>FP</code> and in some cases like
the x86 it’s called Base Pointer, and register name is <code>EBP</code>.</p>
<p>Let’s start with an example program.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>c</span><span class=p>;</span>

    <span class=n>c</span> <span class=o>=</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>

    <span class=k>return</span> <span class=n>c</span><span class=p>;</span>
<span class=p>}</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>int</span> <span class=n>argc</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>argv</span><span class=p>[])</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>,</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>

    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>add</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>));</span>

    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>In the above example code, the first function to be called, as you should
already know, is main, which has a frame for itself. That frame holds all the
variables inside the function. These variables unlike global variables are not
even part of the final code generated, they are created during runtime and all
references of it are offsets from <code>EBP</code>, so <code>a</code> and <code>b</code> in function <code>main</code> will
be referred to as <code>EBP - 4</code> and <code>EBP - 8</code> respectively. In the below assembly
code of beginning of main, the variable creation can be found, but this case its
referred using offsets from <code>ESP</code>, but conceptually both are right.</p>
<pre tabindex=0><code class=language-assembly data-lang=assembly>movl    %esp, %ebp
...
subl    $32, %esp
movl    $10, 28(%esp)
movl    $1, 24(%esp)
</code></pre><p>Since <code>EBP = ESP</code> after <code>mov %esp, %ebp</code>, the new stack frame is created by
moving <code>SP</code> 32 bytes down, so now the next line of code <code>mov $10, 28(%esp)</code>,
which means, move value 10 to address at <code>ESP + 28</code>, which also means <code>EBP - 4</code>. Let’s print addresses of <code>SP</code> and <code>FP</code> in both the functions and see what
else is we can discover. The following snippet shows how you can print the <code>EBP</code>
and <code>ESP</code> in a C program.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span> <span class=k>register</span> <span class=n>fp</span> <span class=nf>asm</span><span class=p>(</span><span class=s>&#34;ebp&#34;</span><span class=p>);</span>
<span class=k>const</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=o>*</span> <span class=k>register</span> <span class=n>sp</span> <span class=nf>asm</span><span class=p>(</span><span class=s>&#34;esp&#34;</span><span class=p>);</span>

<span class=n>printf</span><span class=p>(</span><span class=s>&#34;sp: %p fp: %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>sp</span><span class=p>,</span> <span class=n>fp</span><span class=p>);</span>
</code></pre></div><p>If you see clearly, printing all the addresses of the variables, the frame
pointer and the stack pointer of the main function, you will find that there are
some extra space in the stack, which is used for storing the return address and
the frame pointer of the current frame before calling <code>add()</code>. We will see in
detail about those in the next part of this article, where we will talk about
the x86_64 ABI, which is a little different from what we have seen here about
the 32 bit architecture (unfortunately there is no one size fits all solution).</p>
<p>*[OOM]: Out Of Memory
*[BSS]: Block Started by Segment
*[ABI]: Application Binary Interface</p>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p>History of prefixing E can be found elsewhere. Hint: the move from 16 to
32 bit.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
<hr>
</div><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script>
<script src=/fossix.js></script>
<script src=//ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js></script>
<script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script>
<hr>
<div class=container>
<div class=row>
<div class=mx-auto>
<ul class=nav>
<li class=nav-item>
<a class="nav-link text-muted" href=/about>About</a>
</li>
<li class=nav-item>
<a class="nav-link text-muted" href=/contact/>Contact</a>
</li>
<li class=nav-item>
<a class="nav-link text-muted" href=/privacy/>Privacy Policy</a>
</li>
</ul>
</div>
</div>
<div class=row>
<div class=mx-auto>
<p>Site design and logo and content &copy; fossix.org</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>